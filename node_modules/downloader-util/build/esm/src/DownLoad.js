const fs = require('fs-extra');
const path = require('path');
import axios from 'axios';
import DownloadMoreThread from './DownloadMoreThread';
import { getFileContent, saveJson } from './utils/fileutil';
var DownloadState;
(function (DownloadState) {
    DownloadState[DownloadState["start"] = 0] = "start";
    DownloadState[DownloadState["stop"] = 1] = "stop";
})(DownloadState || (DownloadState = {}));
export class DownLoad {
    constructor(opts) {
        this.retry = 3;
        this.onFailed = (error) => {
            console.log(error);
        };
        const { url, filePath, retry, type = 0, timeout = 5000, threadCount = 10, headers = {}, onProgress, onSuccess, onFailed, } = opts;
        this.url = url;
        this.filePath = filePath;
        this.retry = retry || this.retry;
        this.timeout = timeout;
        this.type = type;
        this.length = 0;
        this.threadCount = threadCount;
        this.headers = headers;
        this.onFailed = onFailed || this.onFailed;
        this.onProgress = onProgress;
        this.onSuccess = onSuccess;
        this.downloadState = DownloadState.stop;
    }
    async start() {
        this.downloadState = DownloadState.start;
        try {
            const response = await axios({
                url: this.url,
                method: 'GET',
                responseType: 'stream',
                timeout: this.timeout,
                headers: this.headers,
            });
            const inputStream = response.data;
            if (this.downloadState !== DownloadState.start) {
                inputStream.destroy();
                return '';
            }
            const length = (this.length = response.headers['content-length'] || 1);
            console.log(`${this.url} 文件长度:${this.getFileSize(length)}`);
            inputStream.destroy();
            if (this.type === 0) {
                if (length < 1024 * 1024 * 10) {
                    //文件小于10M 单线程下载
                    console.log('文件小于10M 直接单线程下载');
                    this.type = 1;
                }
                else {
                    console.log('文件大于10M 启用多线程下载');
                    this.type = 2;
                }
            }
            if (this.type === 1) {
                //文件小于10M 单线程下载
                console.log('开始单线程下载');
                await this.downloadOneThread();
            }
            else {
                // 大于10M 多线程下载
                // inputStream.destroy();//先关闭当前流 开启多线程下载
                console.log('开始多线程下载');
                const downloadMoreThread = (this.downloadMoreThread =
                    new DownloadMoreThread({
                        downloadUrl: this.url,
                        desFile: this.filePath,
                        threadCount: this.threadCount,
                        length,
                        onProgress: this.onProgress,
                    }));
                await downloadMoreThread.start();
            }
        }
        catch (e) {
            setTimeout(() => {
                this.onFailed(e.toString());
            });
            return;
        }
        this.removeConfig(this.filePath);
        setTimeout(() => {
            this.onSuccess && this.onSuccess();
        });
    }
    async downloadOneThread() {
        this.mkFile(this.filePath);
        const config = this.getDownloadConfig(this.filePath);
        let headers = Object.assign({}, this.headers);
        if (config.start == this.length) {
            console.log('下载已完成!直接返回');
            return '';
        }
        if (config.start != 0 && this.length !== 0) {
            headers.Range = `bytes=${config.start}-${this.length}`;
        }
        const response = await axios({
            url: this.url,
            method: 'GET',
            responseType: 'stream',
            timeout: this.timeout,
            headers,
        });
        const inputStream = response.data;
        if (this.downloadState !== DownloadState.start) {
            inputStream.destroy();
            return '';
        }
        // inputStream.pipe(writer);
        const length = response.headers['content-length'] || 1;
        let hasDownloadLength = config.start;
        const doProgress = (newLength) => {
            hasDownloadLength += newLength;
            const progress = hasDownloadLength / (+length + config.start);
            this.onProgress && this.onProgress(progress);
        };
        const onError = async (resolve, reject) => {
            inputStream.destroy();
            if (this.retry > 0) {
                this.retry--;
                fs.removeSync(this.filePath);
                try {
                    await this.downloadOneThread();
                    resolve('');
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                reject(`下载失败,重试${this.retry}次`);
            }
        };
        return new Promise((resolve, reject) => {
            const fd = fs.openSync(this.filePath, 'a');
            let pos = config.start;
            let timeoutHandle = setTimeout(() => {
                console.log('超过10s没有新的数据产生，下载超时');
                onError(resolve, reject);
            }, this.timeout);
            inputStream.on('data', (chunk) => {
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                }
                if (this.downloadState !== DownloadState.start) {
                    inputStream.destroy();
                    reject('用户手动停止，停止下载');
                    return;
                }
                timeoutHandle = setTimeout(() => {
                    console.log('超过10s没有新的数据产生，下载超时');
                    onError(resolve, reject);
                }, this.timeout);
                fs.writeSync(fd, chunk, 0, chunk.length, pos);
                pos += chunk.length;
                this.saveConfig(this.filePath, pos);
                doProgress(chunk.length);
            });
            inputStream.on('end', (data) => {
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                }
                fs.closeSync(fd);
                resolve('');
            });
            inputStream.on('error', (e) => {
                fs.closeSync(fd);
                onError(resolve, reject);
            });
        });
    }
    stop() {
        this.downloadState = DownloadState.stop;
        if (this.downloadMoreThread) {
            this.downloadMoreThread.stop();
        }
    }
    getFileSize(length) {
        const ksize = length / 1024;
        if (ksize < 1024) {
            return ksize.toFixed(2) + 'k';
        }
        const msize = ksize / 1024;
        if (msize < 1024) {
            return msize.toFixed(2) + 'M';
        }
        const gsize = msize / 1024;
        return gsize.toFixed(2) + 'G';
    }
    mkFile(filePath) {
        const pathDes = path.resolve(filePath, '../');
        fs.ensureDirSync(pathDes);
    }
    getDownloadConfig(filePath) {
        const configPath = `${filePath}.config`;
        const content = getFileContent(configPath);
        if (content) {
            return JSON.parse(content);
        }
        return {
            start: 0,
        };
    }
    saveConfig(filePath, pos) {
        const configPath = `${filePath}.config`;
        saveJson(configPath, { start: pos });
    }
    removeConfig(filePath) {
        const configPath = `${filePath}.config`;
        fs.removeSync(configPath);
    }
    downloadThreads() { }
}
